<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>

<title>Postfix Queue Scheduler</title>

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">

</head>

<body>

<h1><img src="postfix-logo.jpg" width="203" height="98" ALT="">Postfix Queue Scheduler</h1>

<hr>

<h2> Overview </h2>

<p> The queue manager is by far the most complex part of the Postfix
mail system. It schedules delivery of new mail, retries failed
deliveries at specific times, and removes mail from the queue after
the last delivery attempt.  There are two major classes of mechanisms
that control the operation of the queue manager. </p>

<p> The first class of mechanisms is concerned with the number of
concurrent deliveries to a specific destination, including decisions
on when to suspend deliveries after persistent failures: </p>

    <ul>

    <li> <a href="#concurrency"> Concurrency scheduling </a>

	<ul>

	<li> <a href="#concurrency_summary_2_5"> Summary of the
	Postfix 2.5 concurrency feedback algorithm </a>

	<li> <a href="#dead_summary_2_5"> Summary of the Postfix
	2.5 "dead destination" detection algorithm </a>

	<li> <a href="#pseudo_code_2_5"> Pseudocode for the Postfix
	2.5 concurrency scheduler </a>

	<li> <a href="#concurrency_results"> Results for delivery
	to concurrency limited servers </a>

	<li> <a href="#concurrency_discussion"> Discussion of
	concurrency limited server results </a>

	<li> <a href="#concurrency_limitations"> Limitations of
	less-than-1 per delivery feedback </a>

	<li> <a href="#concurrency_config"> Concurrency configuration
	parameters </a>

	</ul>

    </ul>

<p> The second class of mechanisms is concerned with the selection
of what mail to deliver to a given destination: </p>

    <ul>

    <li> <a href="#jobs"> Preemptive scheduling </a>

	<ul>

	<li> <a href="#job_motivation"> Why the non-preemptive Postfix queue
	manager was replaced </a>

	<li> <a href="#job_design"> How the non-preemptive queue manager
	scheduler works </a>

	</ul>

    </ul>

<p> And this document would not be complete without: </p>

    <ul>

    <li> <a href="#credits"> Credits </a>

    </ul>

<!--

<p> Once started, the qmgr(8) process runs until "postfix reload"
or "postfix stop".  As a persistent process, the queue manager has
to meet strict requirements with respect to code correctness and
robustness. Unlike non-persistent daemon processes, the queue manager
cannot benefit from Postfix's process rejuvenation mechanism that
limit the impact from resource leaks and other coding errors
(translation: replacing a process after a short time covers up bugs
before they can become a problem).  </p>

-->

<h2> <a name="concurrency"> Concurrency scheduling </a> </h2>

<p> This section documents the Postfix 2.5 concurrency scheduler.
Prior Postfix versions used a simple but robust algorithm where the
per-destination delivery concurrency was decremented by 1 after a
delivery suffered connection or handshake failure, and was incremented
by 1 otherwise.  Of course the concurrency was never allowed to
exceed the maximum per-destination concurrency limit.  And when a
destination's concurrency level dropped to zero, the destination
was declared "dead" and delivery was suspended.  </p>

<p> Drawbacks of the old +/-1 feedback per delivery are: <p>

<ul>

<li> <p> Overshoot due to exponential delivery concurrency growth
with each pseudo-cohort(*). For example, with the default initial
concurrency of 5, concurrency would proceed over time as (5-10-20).
</p>

<li> <p> Throttling down to zero concurrency after a single
pseudo-cohort(*) failure. This was especially an issue with
low-concurrency channels where a single failure could be sufficient
to mark a destination as "dead", causing the suspension of further
deliveries to the affected destination. </p>

</ul>

<p> (*) A pseudo-cohort is a number of delivery requests equal to
a destination's delivery concurrency. </p>

<p> The revised concurrency scheduler has a highly modular structure.
It uses separate mechanisms for per-destination concurrency control
and for "dead destination" detection.  The concurrency control in
turn is built from two separate mechanisms: it supports less-than-1
feedback per delivery to allow for more gradual concurrency
adjustments, and it uses feedback hysteresis to suppress concurrency
oscillations.  And instead of waiting for delivery concurrency to
throttle down to zero, a destination is declared "dead" after a
configurable number of pseudo-cohorts reports connection or handshake
failure.  </p>

<h3> <a name="concurrency_summary_2_5"> Summary of the Postfix 2.5 concurrency feedback algorithm </a> </h3>

<p> We want to increment a destination's delivery concurrency when
some (not necessarily consecutive) number of deliveries complete
without connection or handshake failure.  This is implemented with
positive feedback g(N) where N is the destination's delivery
concurrency.  With g(N)=1 feedback per delivery, concurrency increases
by 1 after each positive feedback event; this gives us the old
scheduler's exponential growth in time. With g(N)=1/N feedback per
delivery, concurrency increases by 1 after an entire pseudo-cohort
N of positive feedback reports; this gives us linear growth in time.
Less-than-1 feedback per delivery and integer truncation naturally
give us hysteresis, so that transitions to larger concurrency happen
every 1/g(N) positive feedback events.  </p>

<p> We want to decrement a destination's delivery concurrency when
some (not necessarily consecutive) number of deliveries complete
after connection or handshake failure.  This is implemented with
negative feedback f(N) where N is the destination's delivery
concurrency.  With f(N)=1 feedback per delivery, concurrency decreases
by 1 after each negative feedback event; this gives us the old
scheduler's behavior where concurrency is throttled down dramatically
after a single pseudo-cohort failure.  With f(N)=1/N feedback per
delivery, concurrency backs off more gently.  Again, less-than-1
feedback per delivery and integer truncation naturally give us
hysteresis, so that transitions to lower concurrency happen every
1/f(N) negative feedback events.  </p>

<p> However, with negative feedback we introduce a subtle twist.
We "reverse" the negative hysteresis cycle so that the transition
to lower concurrency happens at the <b>beginning</b> of a sequence
of 1/f(N) negative feedback events.  Otherwise, a correction for
overload would be made too late.  This makes the choice of f(N)
relatively unimportant, as borne out by measurements later in this
document.  </p>

<p> In summary, the main ingredients for the Postfix 2.5 concurrency
feedback algorithm are a) the option of less-than-1 positive feedback
per delivery to avoid overwhelming servers, b) the option of
less-than-1 negative feedback per delivery to avoid giving up too
fast, c) feedback hysteresis to avoid rapid oscillation, and c) a
"reverse" hysteresis cycle for negative feedback, so that it can
correct for overload quickly.  </p>

<h3> <a name="dead_summary_2_5"> Summary of the Postfix 2.5 "dead destination" detection algorithm </a> </h3>

<p> We want to suspend deliveries to a specific destination after
some number of deliveries suffers connection or handshake failure.
The old scheduler declares a destination "dead" when negative (-1)
feedback throttles the delivery concurrency down to zero. With
less-than-1 feedback per delivery, this throttling down would
obviously take too long.  We therefore have to separate "dead
destination" detection from concurrency feedback.  This is implemented
by introducing the concept of pseudo-cohort failure. The Postfix
2.5 concurrency scheduler declares a destination "dead" after a
configurable number of pseudo-cohorts suffers from connection or
handshake failures. The old scheduler corresponds to the special
case where the pseudo-cohort failure limit is equal to 1.  </p>

<h3> <a name="pseudo_code_2_5"> Pseudocode for the Postfix 2.5 concurrency scheduler </a> </h3>

<p> The pseudo code shows how the ideas behind new concurrency
scheduler are implemented as of November 2007.  The actual code can
be found in the module qmgr/qmgr_queue.c.  </p>

<pre>
Types:
        Each destination has one set of the following variables
        int concurrency
        double success
        double failure
        double fail_cohorts

Feedback functions:
        N is concurrency; x, y are arbitrary numbers in [0..1] inclusive
        positive feedback: g(N) = x/N | x/sqrt(N) | x
        negative feedback: f(N) = y/N | y/sqrt(N) | y

Initialization:
        concurrency = initial_concurrency
        success = 0
        failure = 0
        fail_cohorts = 0

After success:
        fail_cohorts = 0
        Be prepared for feedback > hysteresis, or rounding error
        success += g(concurrency)
        while (success >= 1)            Hysteresis 1
            concurrency += 1            Hysteresis 1
            failure = 0
            success -= 1                Hysteresis 1
        Be prepared for overshoot
        if (concurrency > concurrency limit)
            concurrency = concurrency limit

Safety:
        Don't apply positive feedback unless
            concurrency < busy_refcount + init_dest_concurrency
        otherwise negative feedback effect could be delayed

After failure:
        if (concurrency > 0)
            fail_cohorts += 1.0 / concurrency
            if (fail_cohorts > cohort_failure_limit)
                concurrency = 0
        if (concurrency > 0)
            Be prepared for feedback > hysteresis, rounding errors
            failure -= f(concurrency)
            while (failure < 0)
                concurrency -= 1        Hysteresis 1
                failure += 1            Hysteresis 1
                success = 0
            Be prepared for overshoot
            if (concurrency < 1)
                concurrency = 1
</pre>

<h3> <a name="concurrency_results"> Results for delivery to concurrency limited servers </a> </h3>

<p> Discussions about the concurrency scheduler redesign started
early 2004, when the primary goal was to find alternatives that did
not exhibit exponential growth or rapid concurrency throttling.  No
code was implemented until late 2007, when the primary concern had
shifted towards better handling of server concurrency limits. For
this reason we measure how well the new scheduler does this
job.  The table below compares mail delivery performance of the old
+/-1 feedback per delivery with several less-than-1 feedback
functions, for different limited-concurrency server scenarios.
Measurements were done with a FreeBSD 6.2 client and with FreeBSD
6.2 and various Linux servers.  </p>

<p> Server configuration: </p>

<ul> <li> The mail flow was slowed down with 1 second latency per
recipient ("smtpd_client_restrictions = sleep 1"). The purpose was
to make results less dependent on hardware details, by avoiding
slow-downs by queue file I/O, logging I/O, and network I/O.

<li> Concurrency was limited by the server process limit
("default_process_limit = 5" and "smtpd_client_event_limit_exceptions
= static:all"). Postfix was stopped and started after changing the
process limit, because the same number is also used as the backlog
argument to the listen(2) system call, and "postfix reload" does
not re-issue this call.

<li> Mail was discarded with "local_recipient_maps = static:all" and
"local_transport = discard". The discard action in header/body checks
could not be used as it fails to update the in_flow_delay counters.

</ul>

<p> Client configuration: </p>

<ul>

<li> Queue file overhead was minimized by sending one message to a
virtual alias that expanded into 2000 different remote recipients.
All recipients were accounted for according to the maillog file.
The virtual_alias_expansion_limit setting was increased to avoid
complaints from the cleanup(8) server.

<li> The number of deliveries was maximized with
"smtp_destination_recipient_limit = 2". A smaller limit would cause
Postfix to schedule the concurrency per recipient instead of domain,
which is not what we want.

<li> Maximum concurrency was limited with
"smtp_destination_concurrency_limit = 20", and
initial_destination_concurrency was set to the same value.

<li> The positive and negative concurrency feedback hysteresis was
1.  Concurrency was incremented by 1 at the END of 1/feedback steps
of positive feedback, and was decremented by 1 at the START of
1/feedback steps of negative feedback.

<li> The SMTP client used the default 30s SMTP connect timeout and
300s SMTP greeting timeout.

</ul>

<h4> Impact of the 30s SMTP connect timeout </h4>

<p> The first results are for a FreeBSD 6.2 server, where our
artificially low listen(2) backlog results in a very short kernel
queue for established connections. The table shows that all deferred
deliveries failed due to a 30s connection timeout, and none failed
due to a server greeting timeout.  This measurement simulates what
happens when the server's connection queue is completely full under
load, and the TCP engine drops new connections.  </p>

<blockquote>

<table>

<tr> <th>client<br> limit</th> <th>server<br> limit</th> <th>feedback<br>
style</th> <th>connection<br> caching</th> <th>percentage<br>
deferred</th> <th colspan="2">client concurrency<br> average/stddev</th>
<th colspan=2>timed-out in<br> connect/greeting </th> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">no</td> <td
align="center">9.9</td> <td align="center">19.4</td> <td
align="center">0.49</td> <td align="center">198</td> <td
align="center">-</td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">yes</td> <td
align="center">10.3</td> <td align="center">19.4</td> <td
align="center">0.49</td> <td align="center">206</td> <td
align="center">-</td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">no</td>
<td align="center">10.4</td> <td align="center">19.6</td> <td
align="center">0.59</td> <td align="center">208</td> <td
align="center">-</td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">yes</td>
<td align="center">10.6</td> <td align="center">19.6</td> <td
align="center">0.61</td> <td align="center">212</td> <td
align="center">-</td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">no</td> <td
align="center">10.1</td> <td align="center">19.5</td> <td
align="center">1.29</td> <td align="center">202</td> <td
align="center">-</td> </tr>

<tr><td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">yes</td> <td
align="center">10.8</td> <td align="center">19.3</td> <td
align="center">1.57</td> <td align="center">216</td> <td
align="center">-</td> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

</table>

<p> A busy server with a completely full connection queue.  N is
the client delivery concurrency.  Failed deliveries time out after
30s without completing the TCP handshake. See text for a discussion
of results. </p>

</blockquote>

<h4> Impact of the 300s SMTP greeting timeout </h4>

<p> The next table shows results for a Fedora Core 8 server (results
for RedHat 7.3 are identical). In this case, the artificially small
listen(2) backlog argument does not impact our measurement.  The
table shows that practically all deferred deliveries fail after the
300s SMTP greeting timeout. As these timeouts were 10x longer than
with the first measurement, we increased the recipient count (and
thus the running time) by a factor of 10 to keep the results
comparable. The deferred mail percentages are a factor 10 lower
than with the first measurement, because the 1s per-recipient delay
was 1/300th of the greeting timeout instead of 1/30th of the
connection timeout.  </p>

<blockquote>

<table>

<tr> <th>client<br> limit</th> <th>server<br> limit</th> <th>feedback<br>
style</th> <th>connection<br> caching</th> <th>percentage<br>
deferred</th> <th colspan="2">client concurrency<br> average/stddev</th>
<th colspan=2>timed-out in<br> connect/greeting </th> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">no</td> <td
align="center">1.16</td> <td align="center">19.8</td> <td
align="center">0.37</td> <td align="center">-</td> <td
align="center">230</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">yes</td> <td
align="center">1.36</td> <td align="center">19.8</td> <td
align="center">0.36</td> <td align="center">-</td> <td
align="center">272</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">no</td>
<td align="center">1.21</td> <td align="center">19.9</td> <td
align="center">0.23</td> <td align="center">4</td> <td
align="center">238</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">yes</td>
<td align="center">1.36</td> <td align="center">20.0</td> <td
align="center">0.23</td> <td align="center">-</td> <td
align="center">272</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">no</td> <td
align="center">1.18</td> <td align="center">20.0</td> <td
align="center">0.16</td> <td align="center">-</td> <td
align="center">236</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">yes</td> <td
align="center">1.39</td> <td align="center">20.0</td> <td
align="center">0.16</td> <td align="center">-</td> <td
align="center">278</td> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

</table>

<p> A busy server with a non-full connection queue.  N is the client
delivery concurrency. Failed deliveries complete at the TCP level,
but time out after 300s while waiting for the SMTP greeting.  See
text for a discussion of results.  </p>

</blockquote>

<h4> Impact of active server concurrency limiter </h4>

<p> The final concurrency limited result shows what happens when
SMTP connections don't time out, but are rejected immediately with
the Postfix server's smtpd_client_connection_count_limit feature
(the server replies with a 421 status and disconnects immediately).
Similar results can be expected with concurrency limiting features
built into other MTAs or firewalls.  For this measurement we specified
a server concurrency limit and a client initial destination concurrency
of 5, and a server process limit of 10; all other conditions were
the same as with the first measurement. The same result would be
obtained with a FreeBSD or Linux server, because the "pushing back"
is done entirely by the receiving Postfix. </p>

<blockquote>

<table>

<tr> <th>client<br> limit</th> <th>server<br> limit</th> <th>feedback<br>
style</th> <th>connection<br> caching</th> <th>percentage<br>
deferred</th> <th colspan="2">client concurrency<br> average/stddev</th>
<th>theoretical<br>defer rate</th> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">no</td> <td
align="center">16.5</td> <td align="center">5.17</td> <td
align="center">0.38</td> <td align="center">1/6</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/N</td> <td align="center">yes</td> <td
align="center">16.5</td> <td align="center">5.17</td> <td
align="center">0.38</td> <td align="center">1/6</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">no</td>
<td align="center">24.5</td> <td align="center">5.28</td> <td
align="center">0.45</td> <td align="center">1/4</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1/sqrt(N)</td> <td align="center">yes</td>
<td align="center">24.3</td> <td align="center">5.28</td> <td
align="center">0.46</td> <td align="center">1/4</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">no</td> <td
align="center">49.7</td> <td align="center">5.63</td> <td
align="center">0.67</td> <td align="center">1/2</td> </tr>

<tr> <td align="center">20</td> <td align="center">5</td> <td
align="center">1</td> <td align="center">yes</td> <td
align="center">49.7</td> <td align="center">5.68</td> <td
align="center">0.70</td> <td align="center">1/2</td> </tr>

<tr> <td align="center" colspan="9"> <hr> </td> </tr>

</table>

<p> A server with active per-client concurrency limiter that replies
with 421 and disconnects.  N is the client delivery concurrency.
The theoretical defer rate is 1/(1+roundup(1/feedback)).  This is
always 1/2 with the fixed +/-1 feedback per delivery; with the
concurrency-dependent feedback variants, the defer rate decreases
with increasing concurrency. See text for a discussion of results.
</p>

</blockquote>

<h3> <a name="concurrency_discussion"> Discussion of concurrency limited server results </a> </h3>

<p> All results in the previous sections are based on the first
delivery runs only; they do not include any second etc. delivery
attempts.  The first two examples show that the feedback method
matters little when concurrency is limited due to congestion. This
is because the initial concurrency is already at the client's
concurrency maximum, and because there is 10-100 times more positive
than negative feedback.  Under these conditions, the contribution
from SMTP connection caching is negligible. </p>

<p> In the last example, the old +/-1 feedback per delivery will
defer 50% of the mail when confronted with an active (anvil-style)
server concurrency limit, where the server hangs up immediately
with a 421 status (a TCP-level RST would have the same result).
Less aggressive feedback mechanisms fare better than more aggressive
ones.  Concurrency-dependent feedback fares even better at higher
concurrencies than shown here, but has limitations as discussed in
the next section.  </p>

<h3> <a name="concurrency_limitations"> Limitations of less-than-1 per delivery feedback </a> </h3>

<p> The scheduler with less-than-1 concurrency
feedback per delivery solves a problem with servers that have active
concurrency limiters.  This works only because feedback is handled
in a peculiar manner: positive feedback will increment the concurrency
by 1 at the <b>end</b> of a sequence of events of length 1/feedback,
while negative feedback will decrement concurrency by 1 at the
<b>beginning</b> of such a sequence.  This is how Postfix adjusts
quickly for overshoot without causing lots of mail to be deferred.
Without this difference in feedback treatment, less-than-1 feedback
per delivery would defer 50% of the mail, and would be no better
in this respect than the old +/-1 feedback per delivery.  </p>

<p> Unfortunately, the same feature that corrects quickly for
concurrency overshoot also makes the scheduler more sensitive for
noisy negative feedback.  The reason is that one lonely negative
feedback event has the same effect as a complete sequence of length
1/feedback: in both cases delivery concurrency is dropped by 1
immediately.  As a worst-case scenario, consider multiple servers
behind a load balancer on a single IP address, and no backup MX
address.  When 1 out of K servers fails to complete the SMTP handshake
or drops the connection, a scheduler with 1/N (N = concurrency)
feedback stops increasing its concurrency once it reaches a concurrency
level of about K,  even though the good servers behind the load
balancer are perfectly capable of handling more traffic. </p>

<p> This noise problem gets worse as the amount of positive feedback
per delivery gets smaller.  A compromise is to use fixed less-than-1
positive feedback values instead of concurrency-dependent positive
feedback.  For example, to tolerate 1 of 4 bad servers in the above
load balancer scenario, use positive feedback of 1/4 per "good"
delivery (no connect or handshake error), and use an equal or smaller
amount of negative feedback per "bad" delivery.  The downside of
using concurrency-independent feedback is that some of the old +/-1
feedback problems will return at large concurrencies.  Sites that
deliver at non-trivial per-destination concurrencies will require
special configuration.  </p>

<h3> <a name="concurrency_config"> Concurrency configuration parameters </a> </h3>

<p> The Postfix 2.5 concurrency scheduler is controlled with the
following configuration parameters, where "<i>transport</i>_foo"
provides a transport-specific parameter override.  All parameter
default settings are compatible with earlier Postfix versions. </p>

<blockquote>

<table border="0">

<tr> <th> Parameter name </th> <th> Postfix version </th> <th>
Description </th> </tr>

<tr> <td colspan="3"> <hr> </td> </tr>

<tr> <td> initial_destination_concurrency<br>
<i>transport</i>_initial_destination_concurrency </td> <td
align="center"> all<br> 2.5 </td> <td> Initial per-destination
delivery concurrency </td> </tr>

<tr> <td> default_destination_concurrency_limit<br>
<i>transport</i>_destination_concurrency_limit </td> <td align="center">
all<br> all </td> <td> Maximum per-destination delivery concurrency
</td> </tr>

<tr> <td> default_destination_concurrency_positive_feedback<br>
<i>transport</i>_destination_concurrency_positive_feedback </td>
<td align="center"> 2.5<br> 2.5 </td> <td> Per-destination positive
feedback amount, per delivery that does not fail with connection
or handshake failure </td> </tr>

<tr> <td> default_destination_concurrency_negative_feedback<br>
<i>transport</i>_destination_concurrency_negative_feedback </td>
<td align="center"> 2.5<br> 2.5 </td> <td> Per-destination negative
feedback amount, per delivery that fails with connection or handshake
failure </td> </tr>

<tr> <td> default_destination_concurrency_failed_cohort_limit<br>
<i>transport</i>_destination_concurrency_failed_cohort_limit </td>
<td align="center"> 2.5<br> 2.5 </td> <td> Number of failed
pseudo-cohorts after which a destination is declared "dead" and
delivery is suspended </td> </tr>

<tr> <td> destination_concurrency_feedback_debug</td> <td align="center">
2.5 </td> <td> Enable verbose logging of concurrency scheduler
activity </td> </tr>

<tr> <td colspan="3"> <hr> </td> </tr>

</table>

</blockquote>

<h2> <a name="jobs"> Preemptive scheduling </a> </h2>

<p> This is the beginning of documentation for a preemptive queue
manager scheduling algorithm by Patrik Rak. For a long time, this
code was made available under the name "nqmgr(8)" (new queue manager),
as an optional module. As of Postfix 2.1 this is the default queue
manager, which is always called "qmgr(8)". The old queue manager
will for some time will be available under the name of "oqmgr(8)".
</p>

<h3> <a name="job_motivation"> Why the non-preemptive Postfix queue manager was replaced </a> </h3>

<p> The non-preemptive Postfix scheduler had several limitations
due to unfortunate choices in its design. </p>

<ol>

    <li> <p> Round-robin selection by destination for mail that is
    delivered via the same message delivery transport. The round-robin
    strategy was chosen with the intention to prevent a single
    (destination) site from using up too many mail delivery resources.
    However, that strategy penalized inbound mail on bi-directional
    gateways.  The poor suffering inbound destination would be
    selected only 1/number-of-destinations of the time, even when
    it had more mail than other destinations, and thus mail could
    be delayed. </p>

    <p> Victor Duchovni found a workaround: use different message
    delivery transports, and thus avoid the starvation problem.
    The Patrik Rak scheduler solves this problem by using FIFO
    selection. </p>

    <li> <p> A second limitation of the old Postfix scheduler was
    that delivery of bulk mail would block all other deliveries,
    causing large delays.  Patrik Rak's scheduler allows mail with
    fewer recipients to slip past bulk mail in an elegant manner.
    </p>

</ol>

<h3> <a name="job_design"> How the non-preemptive queue manager scheduler works </a> </h3>

<p> The following text is from Patrik Rak and should be read together
with the postconf(5) manual that describes each configuration
parameter in detail. </p>

<p> From user's point of view, oqmgr(8) and qmgr(8) are both the same,
except for how next message is chosen when delivery agent becomes
available.  You already know that oqmgr(8) uses round-robin by destination
while qmgr(8) uses simple FIFO, except for some preemptive magic.
The postconf(5) manual documents all the knobs the user
can use to control this preemptive magic - there is nothing else
to the preemption than the quite simple conditions described in there.
</p>

<p> As for programmer-level documentation, this will have to be
extracted from all those emails we have exchanged with Wietse [rats!
I hoped that Patrik would do the work for me -- Wietse] But I think
there are no missing bits which we have not mentioned in our
conversations. </p>

<p> However, even from programmer's point of view, there is nothing
more to add to the message scheduling idea itself.  There are few
things which make it look more complicated than it is, but the
algorithm is the same as the user perceives it. The summary of the
differences of the programmer's view from the user's view are: </p>

<ol>

    <li> <p> Simplification of terms for users: The user knows
    about messages and recipients. The program itself works with
    jobs (one message is split among several jobs, one per each
    transport needed to deliver the message) and queue entries
    (each entry may group several recipients for same destination).
    Then there is the peer structure introduced by qmgr(8) which is
    simply per-job analog of the queue structure. </p>

    <li> <p> Dealing with concurrency limits: The actual implementation
    is complicated by the fact that the messages (resp. jobs) may
    not be delivered in the exactly scheduled order because of the
    concurrency limits. It is necessary to skip some "blocker" jobs
    when the concurrency limit is reached and get back to them
    again when the limit permits. </p>

    <li> <p> Dealing with resource limits: The actual implementation is
    complicated by the fact that not all recipients may be read in-core.
    Therefore each message has some recipients in-core and some may
    remain on-file. This means that a) the preemptive algorithm needs
    to work with recipient count estimates instead of exact counts, b)
    there is extra code which needs to manipulate the per-transport
    pool of recipients which may be read in-core at the same time, and
    c) there is extra code which needs to be able to read recipients
    into core in batches and which is triggered at appropriate moments. </p>

    <li> <p> Doing things efficiently: All important things I am
    aware of are done in the minimum time possible (either directly
    or at least when amortized complexity is used), but to choose
    which job is the best candidate for preempting the current job
    requires linear search of up to all transport jobs (the worst
    theoretical case - the reality is much better). As this is done
    every time the next queue entry to be delivered is about to be
    chosen, it seemed reasonable to add cache which minimizes the
    overhead. Maintenance of this candidate cache slightly obfuscates
    things.

</ol>

<p> The points 2 and 3 are those which made the implementation
(look) complicated and were the real coding work, but I believe
that to understand the scheduling algorithm itself (which was the
real thinking work) is fairly easy. </p>

<h2> <a name="credits"> Credits </a> </h2>

<ul>

<li> Wietse Venema designed and implemented the initial queue manager
with per-domain FIFO scheduling, and per-delivery +/-1 concurrency
feedback.

<li> Patrik Rak designed and implemented preemption where mail with
fewer recipients can slip past mail with more recipients.

<li> Wietse Venema initiated a discussion with Patrik Rak and Victor
Duchovni on alternatives for the +/-1 feedback scheduler's aggressive
behavior. This is when K/N feedback was reviewed (N = concurrency).
The discussion ended without a good solution for both negative
feedback and dead site detection.

<li> Victor Duchovni resumed work on concurrency feedback in the
context of concurrency-limited servers.

<li> Wietse Venema then re-designed the concurrency scheduler in
terms of simplest possible concepts: less-than-1 concurrency feedback
per delivery, forward and reverse concurrency feedback hysteresis,
and pseudo-cohort failure. At this same time, concurrency feedback
was separated from dead site detection.

<li> These simplifications, and their modular implementation, helped
to develop further insights into the different roles that positive
and negative concurrency feedback play, and helped to avoid all the
known worst-case scenarios.

</ul>

</body>

</html>
